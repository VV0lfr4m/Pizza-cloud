The components, commonly referred to as beans, in a Spring application con-
text can be declared explicitly with Java or XML, discovered by component
scanning, or automatically configured with Spring Boot autoconfiguration

In a Spring web application, it’s a controller’s job to fetch and process data. And
it’s a view’s job to render that data
-----------------------------------------------------------------
Lombok
@Data -> creates getters/setters/toString/hasCode/equals

Logging
@Slf4j, is a Lombok-provided annotation that, at runtime,
will automatically generate an SLF4J Logger in the class.

Validation
@NotNull
@Size() -> specifies a size and error message
@CreditCardNumber
@Pattern
@Digits
@Valid ->  tells Spring MVC to perform validation on the submitted object
           after it’s bound to the submitted form data and before the processDesign()
           method is called.
-----------------------------------------------------------------

To apply validation in Spring MVC, you need to
 Declare validation rules on the class that is to be validated: specifically, the
Taco class.
 Specify that validation should be performed in the controller methods that
require validation: specifically, the DesignTacoController’s processDesign()
method and OrderController’s processOrder() method.
 Modify the form views to display validation errors.



You can configure security permits via
http
                .authorizeRequests()
                .antMatchers("/design","/orders")
                .hasRole("ROLE_USER")

                .antMatchers("/","/**")
                .permitAll();

   or more flexible

http
   .authorizeRequests()
   .antMatchers("/design", "/orders")
   .access("hasRole('ROLE_USER')")
   .antMatchers(“/”, "/**").access("permitAll")
   ;

   like this

http
.authorizeRequests()
.antMatchers("/design", "/orders")
.access("hasRole('ROLE_USER') && " +
"T(java.util.Calendar).getInstance().get("+
"T(java.util.Calendar).DAY_OF_WEEK) == " +
"T(java.util.Calendar).TUESDAY")
.antMatchers(“/”, "/**").access("permitAll")
;











@Sl4j provides logs
@Data substitutes setters and getters
@NotNull checks that field is not null:)
@Size checks size
@NotBlank checks that fields are filled
@CreditCardNumber validates ccNumber
@Pattern for patterns
@Digits checks quantity of digits
@Valid tells Spring MVC to perform validation on the submitted param

spring.thymeleaf.cache=false changes in browser will be displayed if =true you need to restart app

@ModelAttribute methods are invoked before the controller methods annotated with @RequestMapping are invoked
ensures that the marked object will be created in the model.
@ModelAttribute to indicate that its
value should come from the model and that Spring MVC shouldn’t attempt to bind
request parameters to it.

@SessionAttributes holds attribute along the session

@Entity marks class as a jpa entity

@ManyToMany. A Taco can have many Ingredient objects,
and an Ingredient can be a part of many Tacos.

@Table(name="Taco_Order") Without it, JPA would default to persisting the entities to a table named Order

@Enumerated(EnumType.STRING) without it spring not correct parse type ENUM(0,1,2,3,4...)

@Query permits to do any query with you custom method, nativeQuery value permits use * by example

without class SecurityConfig extends WebSecurityConfigurerAdapter it will display basic authentication dialog box

@ManyToOne annotation on this property indicates that an order belongs to a single user

 There are several ways to determine who the user is. These are a few of the most
common ways:
 Inject a Principal object into the controller method
 Inject an Authentication object into the controller method
 Use SecurityContextHolder to get at the security context
 Use an @AuthenticationPrincipal annotated method


For handling https requests -> you must create a keystore using the JDK’s keytool command-line utility:
$ keytool -keystore mykeys.jks -genkey -alias tomcat -keyalg RSA
pass: pizzacloud

To activate spring cofig profile -> spring.profiles.active=- prod
- prod is a (name) in application-[name].prop or yml
but it should to set it in production environment ->  % export SPRING_PROFILES_ACTIVE=prod
or
% java -jar taco-cloud.jar --spring.profiles.active=prod


@RestController annotation tells Spring that all handler methods in the controller should have their return
value written directly to the body of the response, rather than being carried in the
model to a view for rendering.

Also you can name class with @Controller and mark all handler methods as @Response/Request/Body but it will return ResponseEntity

@RequestMapping annotation also sets a produces attribute.
This specifies that any of the handler methods in DesignTacoController will only
handle requests if the request’s Accept header includes “application/json”.

@CrossOrigin allows clients from any domain to consume the API.



HATEOAS
with it responses on REST requests returns not only data but available actions with them




//also may be JpaRepository or PaginationSortingRepository
//first includes methods of other two
//second provides sorting and pagination methods
//crudRepo -> provides only crud operations